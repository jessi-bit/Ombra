La regola con il tipo della lambda :

1)tEnv[x -> ty]  |- e : t2  
----------------------------------------------------------  (e3)
tEnv |- (Î»(x : ty).e) : FUN (ty, t2)

E' corretta cosi, se la lambda si porta dietro il tipo?

2)E' corretto che nella semantica operazionale il ty della lambda non viene considerato, cosi' come
  non viene considerato nel value (risultato) quando si fa l'eval?

3)Nella verifica dell'uguaglianza di una lambda ad es lam x -> x e lam y -> y sono entrambe la funzione identita', quindi nella verifica 
dell'uguaglianza basta solo controllare i tipi dell'ident lasciando perdere la verifica del fatto che ci sia lo stesso id?
4)POSSIBILE STRADA ALTERNATIVA ? 
type ident = string

type ty = BOOL | FUN of ty * ty
type tenv = Map<ident,ty>

type exp =
    | Lit  of ident
    | Lam of lamExp
    | App  of (lamExp * exp)
    | Bool of bool
    | If   of (exp * exp * exp)
and lamExp = ident * ty * exp

5)+ materiale su Gen.